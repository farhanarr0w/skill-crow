# -*- coding: utf-8 -*-
"""Flask API

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bYgqmvQCPoIDwBPSMz2KmbwhDZOF2-tH
"""

import pymongo
import pandas as pd

# Replace this connection string with your actual MongoDB connection string
connection_string = "mongodb+srv://admin:abc123ef@cluster0.hq1ekox.mongodb.net/"

# Establish a connection to MongoDB
client = pymongo.MongoClient(connection_string)

# Access a specific database
db = client.get_database("SkillCrow")

# Access a specific collection within the database
collection = db.get_collection("Freelancer")
job_collection = db.get_collection("JobPosts")

# Retrieve all documents from the collection
cursor = collection.find()
posts = job_collection.find()

# Convert documents to a DataFrame
df_freelancer = pd.DataFrame(list(cursor))
df_Jobs = pd.DataFrame(list(posts))

# Define the path to save the CSV file
freelancer_file_path = "freelancer.csv"
jobPosts_file_path = "jobposts.csv"

# Save DataFrame to CSV file
df_freelancer.to_csv(freelancer_file_path, index=False)
df_Jobs.to_csv(jobPosts_file_path, index=False)

# Close the connection when done
client.close()

print("CSV files saved successfully.")



dt_free = pd.read_csv("freelancer.csv")
dt_free.info()

dt_jobs = pd.read_csv("jobposts.csv")
dt_jobs.info()



from flask import Flask, request, jsonify
from textblob import TextBlob
import ast

app = Flask(__name__)

# Function to perform sentiment analysis
def analyze_sentiment(text):
    blob = TextBlob(text)
    sentiment = blob.sentiment
    return sentiment

# Function to generate skills based on job title keywords
def generate_skills_from_title(job_title):
    keywords = {
        'app': ['app development', 'software development', 'coding'],
        'developer': ['app development', 'software development', 'coding'],
        'designer': ['ui/ux', 'graphic design', 'web design'],
        'website': ['website development', 'wordpress', 'web design'],
        'bookkeeper': ['accounting', 'bookkeeping'],
        'finance': ['accounting', 'business management', 'finance'],
        'accountant': ['accounting', 'tax accounting', 'bookkeeping'],
        'excel': ['excel', 'data analysis'],
        'project': ['project management', 'data analysis'],
        'copywriter': ['copywriting', 'creative writing', 'content writing'],
        'marketing': ['email marketing', 'social media marketing', 'content writing'],
        'tax': ['tax accounting', 'accounting'],
        'shopify': ['shopify', 'ecommerce', 'web development'],
        'valuation': ['accounting', 'business management', 'finance'],
        'freelancer': ['freelancer', 'virtual assistant', 'remote work'],
        'logo': ['logo design', 'graphic design', 'brand identity design'],
        'email': ['email marketing', 'content writing', 'social media marketing'],
        'financial model': ['finance', 'accounting', 'data analysis'],
        'excel sheets': ['excel', 'data analysis', 'project management']
    }

    required_skills = set()
    job_title_lower = job_title.lower()
    for keyword, skills in keywords.items():
        if keyword in job_title_lower:
            required_skills.update(skills)

    return list(required_skills)

# Function to parse freelancer skills from string to list of skills
def parse_freelancer_skills(raw_skills):
    try:
        skills_list = ast.literal_eval(raw_skills)
        if isinstance(skills_list, list):
            return [skill.strip().lower() for skill in skills_list]
        else:
            return []
    except:
        return []

# Function to recommend freelancers
def recommend_freelancers(freelancer_skills, job_title, job_description, freelancer_ids, top_n):
    required_skills = generate_skills_from_title(job_title)
    sentiment = analyze_sentiment(job_description)
    matching_scores = []

    for i, raw_skills in enumerate(freelancer_skills):
        skills_lower = parse_freelancer_skills(raw_skills)
        match_count = sum(1 for skill in required_skills if skill.lower() in skills_lower)

        if match_count > 0:
            matching_scores.append((freelancer_ids[i], match_count))

    matching_scores.sort(key=lambda x: x[1], reverse=True)
    top_n_freelancers = [freelancer_id for freelancer_id, _ in matching_scores[:top_n]]

    if len(top_n_freelancers) == 0:
        top_n_freelancers = ["No suitable freelancers found"]

    return {
        'recommended_freelancers': top_n_freelancers
    }

@app.route('/recommend', methods=['POST'])
def recommend():
    data = request.json
    job_title = data.get('JobTitle')
    job_description = data.get('JobDescription')

    if not job_title or not job_description:
        return jsonify({"error": "JobTitle and JobDescription are required"}), 400

    recommended_freelancers = recommend_freelancers(
        dt_free.Skills,
        job_title,
        job_description,
        dt_free._id,
        top_n=18
    )

    return jsonify(recommended_freelancers)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

